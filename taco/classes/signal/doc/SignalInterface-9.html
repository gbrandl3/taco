<!-- Generated by Harlequin WebMaker 2.2.3 (24-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>7.   The Signal Interface to HDB</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING9></A>
<A HREF="SignalInterface-10.html"><IMG ALIGN = BOTTOM SRC = "next.gif"></A> <A HREF="SignalInterface-8.html"><IMG ALIGN = BOTTOM SRC = "prev.gif"></A> <A HREF="SignalInterface-1.html"><IMG ALIGN = BOTTOM SRC = "top.gif"></A> <A HREF="SignalInterface-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif"></A> <IMG ALIGN = BOTTOM SRC = "indexg.gif"><P>
The Device Server Signal Interface<P>
<A NAME=HEADING9-0></A>
<H1>7.   The Signal Interface to HDB</H1>
<HR>
 An entry point to the HDB signal library was developed to allow signal configuration in HDB with the same names as they are known in a device class. Using dev_get_sig_config() in the HDB signal library and storing the result of the command DevReadSigValues in the data collector, all signals configured for a device class (in the device server) are dynamically available in HDB with the same names and descriptions. <P>
 But, today the HDB signal library still needs for dynamic loading one module for each device class. It is just a question of copy and paste to install such a module for a device class using the signal interface, but it implies recompilation of the HDB signal library. Studies are going on to change this to avoid recompilation and reinstallation of the HDB signal library in the future.<P>
 Here is an example module for the HDB signal library. This can be copied, but the function names must be changed to the class name the new module will be used for. <P>
<PRE>
#include &lt;API.h&gt;
#include &lt;siggen.h&gt;
/*
 * function prototypes
 */
long RF_FOCUS_load_type (long *error);
long RF_FOCUS_signal_list_init (char *device_name,
                                                   SigDefEntry **signal_list_ptr,
                                                   long *n_signal,
                                                   long *error);

extern long signal_list_init (char *device_name,
                                          SigDefEntry **signal_list_ptr,
                                          long *n_signal,
                                          long *error);
/*
 * The load type function
 */
long RF_FOCUS_load_type (long *error)
{
        return (DS_OK);
}
/*
 * Dynamic signal initialisation function.
 * Uses signals defined on the device server level.
 */

long RF_FOCUS_signal_list_init (char *device_name,
                                                   SigDefEntry **signal_list_ptr,
                                                   long *n_signal,
                                                   long *error)
{
        /*
         * calls the general signal init function, which is
         * used for all classes which implement signals on
         * the device server level.
         */
        if ( signal_list_init (device_name, signal_list_ptr,
                                      n_signal, error) == DS_NOTOK )
            {
            return (DS_NOTOK);
            }
        return (DS_OK);
}
</PRE>
<!-- TOC -->
<HR>
<ADDRESS>The Device Server Signal Interface - 27 FEB 1998</ADDRESS>
<A HREF="SignalInterface-10.html"><IMG ALIGN = BOTTOM SRC = "next.gif"></A> <A HREF="SignalInterface-8.html"><IMG ALIGN = BOTTOM SRC = "prev.gif"></A> <A HREF="SignalInterface-1.html"><IMG ALIGN = BOTTOM SRC = "top.gif"></A> <A HREF="SignalInterface-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif"></A> <IMG ALIGN = BOTTOM SRC = "indexg.gif"><P>
Generated with <A HREF="http://www.harlequin.com/webmaker">Harlequin WebMaker</A><P>
</BODY>
</HTML> 