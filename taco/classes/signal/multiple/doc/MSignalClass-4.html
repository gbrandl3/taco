<!-- Generated by Harlequin WebMaker 2.2.3 (24-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>2.   Class Description</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING4></A>
<A HREF="MSignalClass-5.html"><IMG ALIGN = BOTTOM SRC = "next.gif"></A> <A HREF="MSignalClass-3.html"><IMG ALIGN = BOTTOM SRC = "prev.gif"></A> <A HREF="MSignalClass-1.html"><IMG ALIGN = BOTTOM SRC = "top.gif"></A> <A HREF="MSignalClass-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif"></A> <IMG ALIGN = BOTTOM SRC = "indexg.gif"><P>
Multi Signal Class Users Guide<P>
<A NAME=HEADING4-0></A>
<H1>2.   Class Description</H1>
<HR>
 The multi signal class allows to handle a set of signals implemented for a device. A multi signal object is a list of signal objects (see: Signal Class Users Guide). Executing a method on a multi signal object will execute the same method on all signal objects of the list. All signals handled by same multi signal object must be signals of the same device:<P>
<BLOCKQUOTE>
SR/RF-FOC/TRA3-1/Set-Current<P>
SR/RF-FOC/TRA3-1/Current<P>
SR/RF-FOC/TRA3-1/Voltage<P>
</BLOCKQUOTE>
<A NAME=HEADING4-5></A>
<H2>2.1   The Configuration Resources</H2>
 Because the multi signal object is created as a list of signal objects, the configuration resources for every signal must be specified as described in the section "The Configuration Resources" of the "Signal Class Users Guide".<P>
 As in the signal class the function object_initialise() was modified from the standard device server template. A class_name argument was added to the function to allow the specification of signal resources for a whole class of devices.<P>
<BLOCKQUOTE>
static long object_initialise   (MDSSignal ds, char *dev_class_name, long *error);<P>
</BLOCKQUOTE>
 A list of signal names must be specified for the device class. All devices of the same class treat the same list of signals. For example the signal list of the "RF_FOCUS" device class:<P>
<BLOCKQUOTE>
CLASS/RF_FOCUS/DEFAULT/signal_names:   set-Current \<P>
                                                                             Voltage, \<P>
                                                                          Current<P>
</BLOCKQUOTE>
<A NAME=HEADING4-13></A>
<H2>2.2   <A NAME=MARKER-9-16></A>Functionality</H2>
 The multi signal class offers the same functionality as the signal class but on a list of signals. Alarms can be checked in the same way and all the signals in the list can be reinitialised with the actual resource values by executing the method DevMethodSignalsReset.<P>
 The method DevMethodCheckLimits is not implemented in the multi signal object. Up to now this feature is used to check set-point limits when changing set-points. In this case it is an action on one signal object only. To handle a set-point limit check when working with a multi signal object, a method was implemented to extract the pointer of a signal object from the multi signal object.<P>
<A NAME=HEADING4-16></A>
<H2>2.3   The Methods</H2>
<A NAME=HEADING4-17></A>
<H3>2.3.1   DevMethodClassInitialise</H3>
<UL>
<LI>long class_initialise (long *error)<P>
<LI>Description:<P>
</UL>
<DL>
<DT><DD>Method to initialise the multi signal class. Will be called automatically when an object of this class is created the first time. The routine will be called only once.<P>
</DL>
<UL>
<LI>Arg(s) In: <P>
</UL>
<DL>
<DT><DD>None<P>
</DL>
<UL>
<LI>Arg(s) Out:<P>
</UL>
<DL>
<DT><DD>long *error - Pointer to error code, in case routine fails.<P>
</DL>
<A NAME=HEADING4-25></A>
<H3>2.3.2   DevMethodCreate</H3>
<UL>
<LI>long object_create (char *name, MDSSignal *ds_ptr, long *error)<P>
<LI>Description:<P>
</UL>
<DL>
<DT><DD>Method to create a multi signal object.  <P>
</DL>
<UL>
<LI>Arg(s) In:  <P>
</UL>
<DL>
<DT><DD>char *name - Name of the multi signal object = the device name.<P>
</DL>
<UL>
<LI>Arg(s) Out:<P>
</UL>
<DL>
<DT><DD>MDSSignal *ds_ptr - Pointer to the created multi signal object.<P>
<DT><DD>long *error - Pointer to error code, in case routine fails.<P>
</DL>
<A NAME=HEADING4-34></A>
<H3>2.3.3   DevMethodDestroy</H3>
<UL>
<LI>long object_destroy ( MDSSignal ds_ptr, long *error)<P>
<LI>Description:<P>
</UL>
<DL>
<DT><DD>Method to destroy a multi signal object and to free all memory occupied by the object. <P>
</DL>
<UL>
<LI>Arg(s) In:  <P>
</UL>
<DL>
<DT><DD>MDSSignal ds - Multi signal object to destroy.<P>
</DL>
<UL>
<LI>Arg(s) Out:<P>
</UL>
<DL>
<DT><DD>long *error - Pointer to error code, in case routine fails.<P>
</DL>
<A NAME=HEADING4-42></A>
<H3>2.3.4   DevMethodInitialise</H3>
<UL>
<LI>long object_initialise (MDSSignal ds, char *dev_class_name,  long *error)<P>
<LI>Description:<P>
</UL>
<DL>
<DT><DD>Method to initialise the multi signal object. Reads all levels of specified resources or initialises to default values if no resources were found.<P>
</DL>
<UL>
<LI>Arg(s) In:  <P>
</UL>
<DL>
<DT><DD>MDSSignal ds - Multi signal object to initialise.<P>
<DT><DD>char *dev_class_name - Name of the device class the multi signal object belongs to.<P>
</DL>
<UL>
<LI>Arg(s) Out:<P>
</UL>
<DL>
<DT><DD>long *error - Pointer to error code, in case routine fails.<P>
</DL>
<A NAME=HEADING4-51></A>
<H3>2.3.5   DevMethodReadProperties</H3>
<UL>
<LI>long read_properties (MDSSignal ds, DevVarStringArray *properties, long *error)<P>
<LI>Description:<P>
</UL>
<DL>
<DT><DD>The method returns the properties of all signals defined in the multi signal object as a string array. The first string (element [0]) indicates the number of properties per signal, to have the flexibility to add new properties. The number of elements in the string array will be:<P>
</DL>
<BLOCKQUOTE>
properties.length = (number of properties per signal) * number of signals + 1<P>
</BLOCKQUOTE>
<DL>
<DT><DD>Example for two signals:<P>
</DL>
<BLOCKQUOTE>
properties.length  = 25<P>
properties.sequence[0]   = Number of properties per signal<P>
properties.sequence[1]   = Name of signal 1<P>
properties.sequence[2]    = Label 1<P>
properties.sequence[3]   = Unit 1<P>
properties.sequence[4]   = Format 1<P>
properties.sequence[5]   = Description 1<P>
properties.sequence[6]   = Maximum value 1<P>
properties.sequence[7]   = Minimum value 1<P>
properties.sequence[8]   = Alarm high 1<P>
properties.sequence[9]   = Alarm low 1<P>
properties.sequence[10]   = Delta value 1<P>
properties.sequence[11]   = Time interval 1<P>
properties.sequence[12]   = Multiplier for standard units 1<P>
properties.sequence[13]   = Name of signal 2<P>
properties.sequence[14]    = Label 2<P>
properties.sequence[15]   = Unit 2<P>
properties.sequence[16]   = Format 2<P>
properties.sequence[17]   = Description 2<P>
properties.sequence[18]   = Maximum value 2<P>
properties.sequence[19]   = Minimum value 2<P>
properties.sequence[20]   = Alarm high 2<P>
properties.sequence[21]   = Alarm low 2<P>
properties.sequence[22]   = Delta value 2<P>
properties.sequence[23]   = Time interval 1<P>
properties.sequence[24]   = Multiplier for standard units 2<P>
</BLOCKQUOTE>
<DL>
<DT><DD>Attention: The string array must not bee freed! The returned data is valid until the next call to the method. Than the string array is automatically freed before the new properties are returned.<P>
</DL>
<UL>
<LI>Arg(s) In:  <P>
</UL>
<DL>
<DT><DD>MDSSignal ds - Multi signal object to use.<P>
</DL>
<UL>
<LI>Arg(s) Out:<P>
</UL>
<DL>
<DT><DD>DevVarStringArray *properties - Array of strings containing the properties of all signals in the list..<P>
<DT><DD>long *error - Pointer to error code, in case routine fails.<P>
</DL>
<A NAME=HEADING4-89></A>
<H3>2.3.6   <A NAME=MARKER-9-17></A>DevMethodCheckAlarm</H3>
<UL>
<LI>long check_alarms (MDSSignal ds, DevVarDoubleArray *read_values, <P>
</UL>
<DL>
<DT><DD>                             DevVarLongArray *alarm_states, long *error)<P>
</DL>
<UL>
<LI>Description:<P>
</UL>
<DL>
<DT><DD>The method checks all the specified alarms on signals of the multi signal object. Alarms can be specified as described in the section "Alarms on Signals" in the "Signal Class Users Guide". <P>
<DT><DD>As input the method takes an array of actual read values, defined as an array of double values for the most general case. The result is an array of corresponding alarm states. An alarm state can take the following four values:<P>
</DL>
<BLOCKQUOTE>
DEVHIGH = Exceeded high alarm level.<P>
DEVLOW = Exceeded low alarm level.<P>
DEVEXTRACTED  = Difference between read and set (nominal) value.<P>
DEVRUN = Signal is in the given range.<P>
</BLOCKQUOTE>
<DL>
<DT><DD>The return value of the method indicates:<P>
</DL>
<BLOCKQUOTE>
True = One or more signals indicate alarms<P>
False = No alarms<P>
DS_NOTOK = An error occurred<P>
</BLOCKQUOTE>
<DL>
<DT><DD>Attention: The sequence of alarm states must not bee freed! The returned data is valid until the next call to the method. Than the sequence is automatically freed before the new alarm states are returned.<P>
</DL>
<UL>
<LI>Arg(s) In:  <P>
</UL>
<DL>
<DT><DD>MDSSignal ds - Multi signal object to use.<P>
<DT><DD>DevVarDoubleArray read_values - Signal values to check.<P>
</DL>
<UL>
<LI>Arg(s) Out:<P>
</UL>
<DL>
<DT><DD>DevVarLongArray *alarm_states - Results of the alarm check.<P>
<DT><DD>long *error - Pointer to error code, in case routine fails.<P>
</DL>
<A NAME=HEADING4-110></A>
<H3>2.3.7   DevMethodReadAlarm</H3>
<UL>
<LI>long read_alarms (MDSSignal ds, DevVarStringArray *alarm_mess, long *error)<P>
<LI>Description:<P>
</UL>
<DL>
<DT><DD>Method to read the alarm messages of all pending alarms for the multi signal object. The method "DevMethodReadAlarm" is executed on all signals of the multi signal object. Alarm messages are handled as described in the section "DevMethodReadAlarm" of the "Signal Class Users Guide".<P>
<DT><DD>Attention: The string array must not bee freed! The returned messages are valid until the next call to the method. Than the string array is automatically freed before the new alarm messages are returned.<P>
</DL>
<UL>
<LI>Arg(s) In:  <P>
</UL>
<DL>
<DT><DD>MDSSignal ds - Multi signal object to use.<P>
</DL>
<UL>
<LI>Arg(s) Out:<P>
</UL>
<DL>
<DT><DD>DevVarStringArray *alarm_mess - Array of alarm message of all pending alarms.<P>
<DT><DD>long *error - Pointer to error code, in case routine fails.<P>
</DL>
<A NAME=HEADING4-120></A>
<H3>2.3.8   DevMethodSignalReset</H3>
<UL>
<LI>long reset (MDSSignal ds, long *error)<P>
<LI>Description:<P>
</UL>
<DL>
<DT><DD>Method to reinitialise the properties of all signals of the multi signal object. All properties are updated with their actual resource values.<P>
</DL>
<UL>
<LI>Arg(s) In:  <P>
</UL>
<DL>
<DT><DD>MDSSignal ds - Multi signal object to use.<P>
</DL>
<UL>
<LI>Arg(s) Out:<P>
</UL>
<DL>
<DT><DD>long *error - Pointer to error code, in case routine fails.<P>
</DL>
<!-- TOC --><DL>
<DT><A HREF="MSignalClass-4.html#HEADING4-5"><B>2.1  </B> - The Configuration Resources</A>
<DD>
<DT><A HREF="MSignalClass-4.html#HEADING4-13"><B>2.2  </B> - Functionality</A>
<DD>
<DT><A HREF="MSignalClass-4.html#HEADING4-16"><B>2.3  </B> - The Methods</A>
<DD>
<DT><A HREF="MSignalClass-4.html#HEADING4-17"><B>2.3.1  </B> - DevMethodClassInitialise</A>
<DD>
<DT><A HREF="MSignalClass-4.html#HEADING4-25"><B>2.3.2  </B> - DevMethodCreate</A>
<DD>
<DT><A HREF="MSignalClass-4.html#HEADING4-34"><B>2.3.3  </B> - DevMethodDestroy</A>
<DD>
<DT><A HREF="MSignalClass-4.html#HEADING4-42"><B>2.3.4  </B> - DevMethodInitialise</A>
<DD>
<DT><A HREF="MSignalClass-4.html#HEADING4-51"><B>2.3.5  </B> - DevMethodReadProperties</A>
<DD>
<DT><A HREF="MSignalClass-4.html#HEADING4-89"><B>2.3.6  </B> - DevMethodCheckAlarm</A>
<DD>
<DT><A HREF="MSignalClass-4.html#HEADING4-110"><B>2.3.7  </B> - DevMethodReadAlarm</A>
<DD>
<DT><A HREF="MSignalClass-4.html#HEADING4-120"><B>2.3.8  </B> - DevMethodSignalReset</A>
<DD>
</DL>

<HR>
<ADDRESS>Multi Signal Class Users Guide - 16 FEB 1998</ADDRESS>
<A HREF="MSignalClass-5.html"><IMG ALIGN = BOTTOM SRC = "next.gif"></A> <A HREF="MSignalClass-3.html"><IMG ALIGN = BOTTOM SRC = "prev.gif"></A> <A HREF="MSignalClass-1.html"><IMG ALIGN = BOTTOM SRC = "top.gif"></A> <A HREF="MSignalClass-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif"></A> <IMG ALIGN = BOTTOM SRC = "indexg.gif"><P>
Generated with <A HREF="http://www.harlequin.com/webmaker">Harlequin WebMaker</A><P>
</BODY>
</HTML> 