<!-- Generated by Harlequin WebMaker 2.2.3 (24-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>4.   The Server Side</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING6></A>
<A HREF="SignalInterface-7.html"><IMG ALIGN = BOTTOM SRC = "next.gif"></A> <A HREF="SignalInterface-5.html"><IMG ALIGN = BOTTOM SRC = "prev.gif"></A> <A HREF="SignalInterface-1.html"><IMG ALIGN = BOTTOM SRC = "top.gif"></A> <A HREF="SignalInterface-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif"></A> <IMG ALIGN = BOTTOM SRC = "indexg.gif"><P>
The Device Server Signal Interface<P>
<A NAME=HEADING6-0></A>
<H1>4.   The Server Side</H1>
<HR>
<A NAME=HEADING6-1></A>
<H2>4.1   The Commands to Access Signals</H2>
 Three commands must be defined in a device class to access signals. One to read an array of signal values, one to identify and to describe each signal value and one to update changed signal properties.<P>
<A NAME=HEADING6-3></A>
<H3>4.1.1   DevReadSigValues</H3>
 The command reads an array of signal values. The array should contain all signals for this class. The data type for all signals of a class must be the same. Possible data types are long values, float values or double values. The command must always return an array, even if only one signal value is defined.<P>
 To avoid the polling of several commands in the data collector, the state of a device should be also treated as a signal and should be returned as the signal "DOMAIN/FAMILY/MEMBER/State" by this command.<P>
 Command list entry:<P>
 DevReadSigValues, read_signal_values, D_VOID_TYPE, D_VAR_FLOATARR, READ_ACCESS<P>
 Command function definition:<P>
<UL>
<LI>long read_signal_vlaues (xxx ds, DevVoid *argin, DevVarFloat Array *argout, long *error)<P>
<LI>Description:<P>
</UL>
<DL>
<DT><DD>Returns the signal values of a device.<P>
</DL>
<UL>
<LI>Arg(s) In: <P>
</UL>
<DL>
<DT><DD>None<P>
</DL>
<UL>
<LI>Arg(s) Out:<P>
</UL>
<DL>
<DT><DD>DevVarFloatArray signal_values - Array of signal values.<P>
<DT><DD>long *error - Pointer to error code, in case routine fails.<P>
</DL>
<A NAME=HEADING6-17></A>
<H3>4.1.2   DevGetSigConfig</H3>
 The command reads the properties of all signals returned by DevReadSigValues. The order of the signals must be the same for the two commands. The first value returned by DevReadSigValues must correspond to the first set of properties returned by DevReadSigConfig.<P>
 The properties of all signals of a class are returned as a string array. The first string (element [0]) must indicate the number of properties per signal, to have the flexibility to add new properties. The number of elements in the string array will be:<P>
<BLOCKQUOTE>
 length = number of properties * number of signals + 1<P>
</BLOCKQUOTE>
 The properties of the signals must be added to the string array by using the result of the method DevMethodReadProperties on the signal or multi signal object (see: the user guides of the two classes).<P>
 Command list entry:<P>
 DevReadSigConfig, read_signal_config, D_VOID_TYPE, D_VAR_STRINGARR, READ_ACCESS<P>
 Command function definition:<P>
<UL>
<LI>long read_signal_config (xxx ds, DevVoid *argin, DevVarStringArray *argout, long *error)<P>
<LI>Description:<P>
</UL>
<DL>
<DT><DD>Returns the signal properties of all signals of a device.<P>
</DL>
<UL>
<LI>Arg(s) In: <P>
</UL>
<DL>
<DT><DD>None<P>
</DL>
<UL>
<LI>Arg(s) Out:<P>
</UL>
<DL>
<DT><DD>DevVarStringArray signal_values - Array of signal properties.<P>
<DT><DD>long *error - Pointer to error code, in case routine fails.<P>
</DL>
<A NAME=HEADING6-33></A>
<H3>4.1.3   DevUpdateSigConfig</H3>
 The command reinitialises all signal properties of all signals of a device. After an update of the resource database calling this command reinitialises all signal properties dynamically with their actual resource values. The goal is an interactive resource editor with a direct update of the device configuration.<P>
 The method DevMethodSignalsReset must be used on the signal or multi signal object (see: the user guides of the two classes)<P>
 Command list entry:<P>
 DevUpdatedSigConfig, update_signal_config, D_VOID_TYPE, D_VOID_TYPE, READ_ACCESS<P>
 Command function definition:<P>
<UL>
<LI>long update_signal_config (xxx ds, DevVoid *argin, DevVoid *argout, long *error)<P>
<LI>Description:<P>
</UL>
<DL>
<DT><DD>Reinitialises all signal properties of all signals of a device with the actual resource values.<P>
</DL>
<UL>
<LI>Arg(s) In: <P>
</UL>
<DL>
<DT><DD>None<P>
</DL>
<UL>
<LI>Arg(s) Out:<P>
</UL>
<DL>
<DT><DD>None<P>
</DL>
<A NAME=HEADING6-46></A>
<H2>4.2   Coding Example using a Multi Signal Object</H2>
 This example is for a device server written in "C". For the use in a "C++" device server the multi signal object must be created via the OIC interface, but can be used with the same functionality.<P>
 To use a multi signal object it must be created and initialised in the object_initialise() method:<P>
<PRE>
        #include &lt;MDSSignalP.h&gt;
        #include &lt;MDSSignal.h&gt;

        /*
         * Create the signal objects specified for this class
         */
         if (ds__create (ds-&gt;devserver.name, mDSSignalClass,
                               &amp;ds-&gt;focus.msignal_obj, error) == DS_NOTOK)
            {
            return(DS_NOTOK);
            }
         if (ds__method_finder (ds-&gt;focus.msignal_obj, DevMethodInitialise)
               (ds-&gt;focus.msignal_obj, focusClass-&gt;devserver_class.class_name, 
               error) == DS_NOTOK)
            {
            return(DS_NOTOK);
            }
</PRE>
 Afterwards two commands can be implemented using the multi signal object:<P>
<PRE>
===================================================== 
 Function:  	static long read_signal_config()
 Description:	Read the properties of all signals specified
 	for the focus power supply.
 Arg(s) In:	Focus ds       - pointer to object
 	void  *argin  - no input arguments
 Arg(s) Out:	DevVarStringArray  *argout - Array of signal properties
	long *error   - pointer to error code, in case routine fails
=====================================================
static long read_signal_config (Focus ds, DevVoid *argin,
                                                   DevVarStringArray *argout, long *error)
{
        *error = 0;
         if (ds__method_finder (ds-&gt;focus.msignal_obj,
                                           DevMethodReadProperties)
                (ds-&gt;focus.msignal_obj, argout, error) == DS_NOTOK)
               {
                return(DS_NOTOK);
               }
        return (DS_OK);
}

=====================================================
 Function: 	static long update_signal_config()
 Description:	Reinitialises all specified signal properties with
 	their actual resource values..
 Arg(s) In:	Focus ds       - pointer to object
 	void  *argin  - no input arguments
 Arg(s) Out:	void  *argout - no outgoing arguments
 	long *error     - pointer to error code, in case routine fails
====================================================
static  long    update_signal_config (Focus ds, DevVoid *argin,
                                                      DevVoid *argout, long *error)
{
         *error=0;
         if (ds__method_finder (ds-&gt;focus.msignal_obj, 
                                            DevMethodSignalsReset)
              (ds-&gt;focus.msignal_obj, error) == DS_NOTOK)
             {
              return(DS_NOTOK);
             }
         return(DS_OK);
}
</PRE>
 The third command just has to return an array of values which must be ordered as the signal properties!<P>
<PRE>
==================================================== 
 Function:	static long read_signal_values()
 Description:	Read the measurement and setpoint values
 	for this device.
	[0] : current setpoint
 	[1] : voltage
  	[2] : current
 Arg(s) In:	Focus ds      - pointer to object
 	void  *argin  - no input arguments
 Arg(s) Out:	DevVarFloatArray  *argout - Array of signal values..
	long *error   - pointer to error code, in case routine fails
=====================================================
static  long read_signal_values (Focus ds, DevVoid *argin,
                                                     DevVarFloatArray  *argout, long *error)
{
        static float       values[3];
        *error = 0;
        .................
        -&gt; Read the signal values here!
       .................
        argout-&gt;length     = 3;
        argout-&gt;sequence = &amp;values[0]; 
        return (DS_OK);
}
</PRE>
 In the SRRF3 project the signal objects are also used to check the limits of incoming set-point values and to handle alarms on signals which change the state on a device.<P>
<!-- TOC --><DL>
<DT><A HREF="SignalInterface-6.html#HEADING6-1"><B>4.1  </B> - The Commands to Access Signals</A>
<DD>
<DT><A HREF="SignalInterface-6.html#HEADING6-3"><B>4.1.1  </B> - DevReadSigValues</A>
<DD>
<DT><A HREF="SignalInterface-6.html#HEADING6-17"><B>4.1.2  </B> - DevGetSigConfig</A>
<DD>
<DT><A HREF="SignalInterface-6.html#HEADING6-33"><B>4.1.3  </B> - DevUpdateSigConfig</A>
<DD>
<DT><A HREF="SignalInterface-6.html#HEADING6-46"><B>4.2  </B> - Coding Example using a Multi Signal Object</A>
<DD>
</DL>

<HR>
<ADDRESS>The Device Server Signal Interface - 27 FEB 1998</ADDRESS>
<A HREF="SignalInterface-7.html"><IMG ALIGN = BOTTOM SRC = "next.gif"></A> <A HREF="SignalInterface-5.html"><IMG ALIGN = BOTTOM SRC = "prev.gif"></A> <A HREF="SignalInterface-1.html"><IMG ALIGN = BOTTOM SRC = "top.gif"></A> <A HREF="SignalInterface-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif"></A> <IMG ALIGN = BOTTOM SRC = "indexg.gif"><P>
Generated with <A HREF="http://www.harlequin.com/webmaker">Harlequin WebMaker</A><P>
</BODY>
</HTML> 